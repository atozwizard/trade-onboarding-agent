"""
Email Coach Agent - ì´ë©”ì¼ ì‘ì„±/ê²€í†  ì—ì´ì „íŠ¸

ê¸°ëŠ¥:
- Draft Mode: ì´ë©”ì¼ ì´ˆì•ˆ ì‘ì„±
- Review Mode: ì´ë©”ì¼ ê²€í†  + ë¦¬ìŠ¤í¬ íƒì§€ + í†¤ ë¶„ì„

Phase 1 êµ¬í˜„: ê¸°ë³¸ ê³¨ê²© + ëª¨ë“œ ê°ì§€ + ë”ë¯¸ ì‘ë‹µ
Phase 2 êµ¬í˜„: RAG ì—°ë™ (ê²€ìƒ‰ ê²°ê³¼ í¬í•¨)
Phase 3 êµ¬í˜„: LLM ì—°ë™ (Draft Mode ì™„ì„±)
"""
import logging
import json
import re
from typing import Dict, List, Literal, Optional

from backend.agents.base import BaseAgent, AgentResponse
from backend.ports import LLMGateway, DocumentRetriever
from backend.prompts.email_prompt import load_all_prompts


class EmailCoachAgent(BaseAgent):
    """
    ì´ë©”ì¼ ì½”ì¹­ ì—ì´ì „íŠ¸

    Attributes:
        prompts: ë¡œë”©ëœ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ë“¤
    """

    def __init__(self, llm: LLMGateway, retriever: DocumentRetriever):
        """
        ì—ì´ì „íŠ¸ ì´ˆê¸°í™”

        Args:
            llm: LLM Gateway (Upstage Solar ë“±)
            retriever: Document Retriever (ChromaDB ë“±)
        """
        self._llm = llm
        self._retriever = retriever
        self.prompts = load_all_prompts()
        self._logger = logging.getLogger(__name__)
        self._logger.info("Email Coach Agent initialized")

    def run(self, user_input: str, context: Dict) -> AgentResponse:
        """
        BaseAgent ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„

        Args:
            user_input: ì‚¬ìš©ì ì…ë ¥
                - Draft: "ë¯¸êµ­ ë°”ì´ì–´ì—ê²Œ ê²¬ì  ìš”ì²­ ì´ë©”ì¼ ì‘ì„±í•´ì¤˜"
                - Review: "ë‹¤ìŒ ì´ë©”ì¼ ê²€í† í•´ì¤˜: Hi, ..."

            context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
                {
                    "mode": "draft" | "review" (ì„ íƒ, ìë™ ê°ì§€ ê°€ëŠ¥),
                    "email_content": str (Review ëª¨ë“œ ì‹œ í•„ìš”),
                    "situation": str (Draft ëª¨ë“œ, ì„ íƒ),
                    "recipient_country": str (ì„ íƒ),
                    "relationship": str (ì„ íƒ),
                    "purpose": str (Review ëª¨ë“œ, ì„ íƒ)
                }

        Returns:
            AgentResponse with:
                - response: str (ë§ˆí¬ë‹¤ìš´ í˜•ì‹ ì‘ë‹µ)
                - agent_type: "email"
                - metadata: {
                    "mode": "draft" | "review",
                    "risks": List[Dict],      # Review ëª¨ë“œì¼ ê²½ìš°
                    "tone_score": float,      # Review ëª¨ë“œì¼ ê²½ìš°
                    "sources": List[str]      # RAG ê²€ìƒ‰ ê²°ê³¼ ì¶œì²˜
                }
        """
        self._logger.info(f"Email Coach Agent Running with input: {user_input[:50]}...")
        self._logger.debug(f"Context: {context}")

        # 1. ëª¨ë“œ ìë™ ê°ì§€
        mode = self._detect_mode(user_input, context)
        self._logger.info(f"Detected mode: {mode}")

        # 2. ëª¨ë“œë³„ ë¼ìš°íŒ…
        if mode == "draft":
            return self._draft_mode(user_input, context)
        else:
            return self._review_mode(user_input, context)

    def _detect_mode(
        self,
        user_input: str,
        context: Dict
    ) -> Literal["draft", "review"]:
        """
        ì‚¬ìš©ì ì…ë ¥ì—ì„œ ëª¨ë“œ ìë™ ê°ì§€

        Rules:
        1. context["mode"] ëª…ì‹œ ì‹œ ìš°ì„  ì‚¬ìš©
        2. "ê²€í† ", "í™•ì¸", "ë¦¬ìŠ¤í¬", "review", "check" â†’ review
        3. "ì‘ì„±", "ì´ˆì•ˆ", "ë§Œë“¤ì–´", "draft", "write" â†’ draft
        4. context["email_content"] ì¡´ì¬ â†’ review
        5. Default: draft

        Args:
            user_input: ì‚¬ìš©ì ì…ë ¥
            context: ì»¨í…ìŠ¤íŠ¸

        Returns:
            "draft" | "review"
        """
        # Rule 1: ëª…ì‹œì  ëª¨ë“œ
        if "mode" in context:
            return context["mode"]

        # Rule 2: Review í‚¤ì›Œë“œ
        review_keywords = ["ê²€í† ", "í™•ì¸", "ë¦¬ìŠ¤í¬", "ì²´í¬", "review", "check"]
        user_input_lower = user_input.lower()

        if any(kw in user_input_lower for kw in review_keywords):
            return "review"

        # Rule 3: Draft í‚¤ì›Œë“œ
        draft_keywords = ["ì‘ì„±", "ì´ˆì•ˆ", "ë§Œë“¤ì–´", "draft", "write"]
        if any(kw in user_input_lower for kw in draft_keywords):
            return "draft"

        # Rule 4: email_content ì¡´ì¬
        if "email_content" in context and context["email_content"]:
            return "review"

        # Rule 5: Default
        return "draft"

    def _draft_mode(self, user_input: str, context: Dict) -> AgentResponse:
        """
        Draft Mode: ì´ë©”ì¼ ì´ˆì•ˆ ì‘ì„±

        Phase 1: ë”ë¯¸ ì‘ë‹µ ë°˜í™˜
        Phase 2: RAG ì—°ë™
        Phase 3: LLM í˜¸ì¶œ + ì‹¤ì œ ì´ë©”ì¼ ìƒì„± â† í˜„ì¬ ë‹¨ê³„

        Args:
            user_input: ì‚¬ìš©ì ìš”ì²­
            context: ìƒí™©, ìˆ˜ì‹ ì êµ­ê°€ ë“±

        Returns:
            AgentResponse
        """
        self._logger.info("Draft Mode activated")

        situation = context.get("situation", "")
        recipient_country = context.get("recipient_country", "")
        relationship = context.get("relationship", "")

        # Phase 2: RAG ê²€ìƒ‰ - ìš°ìˆ˜ ì´ë©”ì¼ ì‚¬ë¡€
        self._logger.info("Searching for email templates...")

        # ê²€ìƒ‰ ì¿¼ë¦¬ êµ¬ì„±
        search_query = f"{user_input}"
        if situation:
            search_query += f" {situation}"

        # RAG ê²€ìƒ‰ ì‹¤í–‰
        try:
            retrieved_docs = self._retriever.search(
                query=search_query,
                k=3,
                document_type="email"
            )
            self._logger.info(f"Found {len(retrieved_docs)} email templates")
        except Exception as e:
            self._logger.warning(f"RAG search failed: {e}")
            retrieved_docs = []

        # ê²€ìƒ‰ ê²°ê³¼ í¬ë§·íŒ… (í”„ë¡¬í”„íŠ¸ìš©)
        formatted_emails_for_prompt = self._format_retrieved_docs_for_prompt(retrieved_docs)

        # Phase 3: LLM í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        self._logger.info("Generating email with LLM...")

        prompt = self.prompts["draft"].format(
            user_input=user_input,
            situation=situation or "general business communication",
            recipient_country=recipient_country or "N/A (adjust tone to be universally professional)",
            relationship=relationship or "professional business relationship",
            retrieved_emails=formatted_emails_for_prompt
        )

        # LLM í˜¸ì¶œ
        try:
            generated_email = self._llm.invoke(prompt)
            self._logger.info(f"Email generated ({len(generated_email)} characters)")
        except Exception as e:
            self._logger.error(f"LLM error: {e}")
            generated_email = f"""[LLM í˜¸ì¶œ ì‹¤íŒ¨: {str(e)}]

Dear [Buyer Name],

I hope this email finds you well.

[ì´ë©”ì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. í”„ë¡¬í”„íŠ¸ë¥¼ í™•ì¸í•˜ê±°ë‚˜ API í‚¤ë¥¼ ì ê²€í•´ì£¼ì„¸ìš”.]

Best regards,
[Your Name]"""

        # Phase 3: ì²´í¬ë¦¬ìŠ¤íŠ¸ ìë™ ìƒì„±
        checklist = self._generate_checklist(generated_email)

        # ì¶œì²˜ ì¶”ì¶œ
        sources = [doc.metadata.get("source_dataset", "unknown") for doc in retrieved_docs]

        # ìµœì¢… ì‘ë‹µ í¬ë§·íŒ…
        response_text = f"""### ğŸ“§ ì‘ì„±ëœ ì´ë©”ì¼ ì´ˆì•ˆ

```
{generated_email}
```

---

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
{checklist}

---

### ğŸ“š ì°¸ê³ í•œ ì´ë©”ì¼ ìƒ˜í”Œ ({len(retrieved_docs)}ê°œ)

{self._format_retrieved_docs(retrieved_docs)[:500]}{"..." if len(self._format_retrieved_docs(retrieved_docs)) > 500 else ""}

---

**ì¶œì²˜**: {self._format_sources(sources)}

**âœ… Phase 3 ì™„ë£Œ**: RAG ê¸°ë°˜ ì‹¤ì œ ì´ë©”ì¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì¦‰ì‹œ ì „ì†¡ ê°€ëŠ¥í•©ë‹ˆë‹¤!
"""

        return AgentResponse(
            response=response_text,
            agent_type="email",
            metadata={
                "mode": "draft",
                "sources": sources,
                "retrieved_count": len(retrieved_docs),
                "email_length": len(generated_email),
                "phase": 3  # Phase 3 ì™„ë£Œ
            }
        )

    def _review_mode(self, user_input: str, context: Dict) -> AgentResponse:
        """
        Review Mode: ì´ë©”ì¼ ê²€í†  + ë¦¬ìŠ¤í¬ íƒì§€

        Phase 1: ë”ë¯¸ ì‘ë‹µ ë°˜í™˜
        Phase 2: RAG ì—°ë™ (ì‹¤ìˆ˜ ì‚¬ë¡€ ê²€ìƒ‰)
        Phase 4: ë¦¬ìŠ¤í¬ íƒì§€ êµ¬í˜„ â† í˜„ì¬ ë‹¨ê³„
        Phase 5: í†¤ ë¶„ì„ + ìˆ˜ì •ì•ˆ êµ¬í˜„

        Args:
            user_input: ì‚¬ìš©ì ì…ë ¥
            context: ì´ë©”ì¼ ë‚´ìš©, ìˆ˜ì‹ ì êµ­ê°€ ë“±

        Returns:
            AgentResponse
        """
        self._logger.info("Review Mode activated")

        # ì´ë©”ì¼ ë‚´ìš© ì¶”ì¶œ
        email_content = context.get("email_content", "")
        if not email_content:
            # user_inputì—ì„œ ì¶”ì¶œ ì‹œë„
            email_content = self._extract_email_from_input(user_input)

        if not email_content:
            return AgentResponse(
                response="âŒ **ì˜¤ë¥˜**: ê²€í† í•  ì´ë©”ì¼ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.\n\n`context['email_content']`ì— ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.",
                agent_type="email",
                metadata={
                    "mode": "review",
                    "error": "missing_email_content"
                }
            )

        # Phase 2: RAG ê²€ìƒ‰ - ì‹¤ìˆ˜ ì‚¬ë¡€
        self._logger.info("Searching for mistake cases...")

        try:
            # ì‹¤ìˆ˜ ì‚¬ë¡€ ê²€ìƒ‰ (mistakes.json)
            retrieved_mistakes = self._retriever.search(
                query=email_content,
                k=5,
                document_type="common_mistake"
            )
            self._logger.info(f"Found {len(retrieved_mistakes)} mistake cases")

            # ìš°ìˆ˜ ì´ë©”ì¼ ì‚¬ë¡€ë„ ì°¸ê³ ìš©ìœ¼ë¡œ ê²€ìƒ‰
            retrieved_emails = self._retriever.search(
                query=email_content,
                k=2,
                document_type="email"
            )
            self._logger.info(f"Found {len(retrieved_emails)} email templates (reference)")

        except Exception as e:
            self._logger.warning(f"RAG search failed: {e}")
            retrieved_mistakes = []
            retrieved_emails = []

        # Phase 4: ë¦¬ìŠ¤í¬ íƒì§€
        self._logger.info("Analyzing risks with LLM...")
        risks = self._detect_risks(email_content, retrieved_mistakes, context)
        self._logger.info(f"Detected {len(risks)} risks")

        # Phase 5: í†¤ ë¶„ì„
        self._logger.info("Analyzing tone...")
        tone_analysis = self._analyze_tone(email_content, retrieved_emails, context)
        self._logger.info(f"Tone score: {tone_analysis.get('score', 0)}/10")

        # Phase 5: ì™„ì „í•œ ìˆ˜ì •ì•ˆ ìƒì„± (LLM)
        self._logger.info("Generating complete improvement...")
        improved_email = self._generate_improvement_complete(
            email_content,
            risks,
            tone_analysis,
            retrieved_emails
        )

        # ê²€ìƒ‰ ê²°ê³¼ í¬ë§·íŒ…
        formatted_mistakes = self._format_retrieved_docs(retrieved_mistakes)

        # ì¶œì²˜ ì¶”ì¶œ
        sources = []
        for doc in retrieved_mistakes:
            sources.append(doc.metadata.get("source_dataset", "unknown"))
        for doc in retrieved_emails:
            sources.append(doc.metadata.get("source_dataset", "unknown"))

        # Phase 5: ë¦¬ìŠ¤í¬ + í†¤ ë¶„ì„ í¬í•¨ëœ ìµœì¢… ì‘ë‹µ
        response_text = f"""### ğŸš¨ ë°œê²¬ëœ ë¦¬ìŠ¤í¬ ({len(risks)}ê±´)

{self._format_risks(risks)}

---

### ğŸ¨ í†¤ ë¶„ì„ ê²°ê³¼

{tone_analysis.get('summary', 'N/A')}

**í˜„ì¬ í†¤**: {tone_analysis.get('current_tone', 'unknown')}
**ê¶Œì¥ í†¤**: {tone_analysis.get('recommended_tone', 'professional')}
**í†¤ ì ìˆ˜**: {tone_analysis.get('score', 0)}/10

---

### ğŸ“ ìˆ˜ì •ì•ˆ

**Before**:
```
{email_content}
```

**After**:
```
{improved_email}
```

---

### ğŸ“š ê°œì„  í¬ì¸íŠ¸

{self._format_improvements_with_tone(risks, tone_analysis)}

---

### ğŸ’¡ ì°¸ê³ í•œ ì‹¤ìˆ˜ ì‚¬ë¡€ ({len(retrieved_mistakes)}ê°œ)

{formatted_mistakes[:400]}{"..." if len(formatted_mistakes) > 400 else ""}

---

**ì¶œì²˜**: {self._format_sources(sources)}

**âœ… Phase 5 ì™„ë£Œ**: ë¦¬ìŠ¤í¬ íƒì§€, í†¤ ë¶„ì„, ì™„ì „í•œ ìˆ˜ì •ì•ˆì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!
"""

        return AgentResponse(
            response=response_text,
            agent_type="email",
            metadata={
                "mode": "review",
                "risks": risks,
                "risk_count": len(risks),
                "tone_score": tone_analysis.get('score', 0),
                "current_tone": tone_analysis.get('current_tone', 'unknown'),
                "sources": sources,
                "retrieved_mistakes": len(retrieved_mistakes),
                "retrieved_emails": len(retrieved_emails),
                "phase": 5  # Phase 5 ì™„ë£Œ
            }
        )

    # ========== Helper Methods ==========

    def _detect_risks(
        self,
        email_content: str,
        retrieved_mistakes: List,
        context: Dict
    ) -> List[Dict]:
        """
        ì´ë©”ì¼ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ë¦¬ìŠ¤í¬ íƒì§€

        Args:
            email_content: ê²€í† í•  ì´ë©”ì¼
            retrieved_mistakes: RAGë¡œ ê²€ìƒ‰ëœ ì‹¤ìˆ˜ ì‚¬ë¡€
            context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸

        Returns:
            ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸
            [
                {
                    "type": str,
                    "severity": "critical" | "high" | "medium",
                    "current": str,
                    "risk": str,
                    "recommendation": str
                },
                ...
            ]
        """
        # ì‹¤ìˆ˜ ì‚¬ë¡€ í¬ë§·íŒ…
        formatted_mistakes = self._format_retrieved_docs_for_prompt(retrieved_mistakes)

        # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        prompt = self.prompts["risk"].format(
            email_content=email_content,
            retrieved_mistakes=formatted_mistakes
        )

        # LLM í˜¸ì¶œ
        try:
            response = self._llm.invoke(prompt)
            risks = self._parse_risks_response(response)

            # ì‹¬ê°ë„ ìˆœ ì •ë ¬ (critical > high > medium)
            severity_order = {"critical": 1, "high": 2, "medium": 3, "low": 4}
            risks.sort(key=lambda x: severity_order.get(x.get("severity", "low"), 99))

            return risks[:5]  # ìµœëŒ€ 5ê°œ

        except Exception as e:
            self._logger.warning(f"Risk detection error: {e}")
            # í´ë°±: ê¸°ë³¸ ë¦¬ìŠ¤í¬ ì²´í¬
            return self._basic_risk_check(email_content)

    def _parse_risks_response(self, response: str) -> List[Dict]:
        """
        LLM ì‘ë‹µì—ì„œ ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸ íŒŒì‹±

        Args:
            response: LLM ì‘ë‹µ (JSON í˜•ì‹ ê¸°ëŒ€)

        Returns:
            íŒŒì‹±ëœ ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸
        """
        # JSON ë¸”ë¡ ì¶”ì¶œ ì‹œë„
        json_match = re.search(r'```json\n(.*?)\n```', response, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
        else:
            # JSON ë¸”ë¡ ì—†ìœ¼ë©´ ì „ì²´ë¥¼ JSONìœ¼ë¡œ ì‹œë„
            json_str = response.strip()

        try:
            parsed = json.loads(json_str)

            # ë¦¬ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
            if isinstance(parsed, list):
                return parsed
            elif isinstance(parsed, dict) and "risks" in parsed:
                return parsed["risks"]
            else:
                self._logger.warning("Unexpected JSON format")
                return []

        except json.JSONDecodeError as e:
            self._logger.warning(f"JSON parsing failed: {e}")
            # í´ë°±: í…ìŠ¤íŠ¸ íŒŒì‹± ì‹œë„
            return self._parse_risks_from_text(response)

    def _parse_risks_from_text(self, text: str) -> List[Dict]:
        """
        JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ í…ìŠ¤íŠ¸ì—ì„œ ë¦¬ìŠ¤í¬ ì¶”ì¶œ

        Args:
            text: LLM ì‘ë‹µ í…ìŠ¤íŠ¸

        Returns:
            ì¶”ì¶œëœ ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸
        """
        risks = []

        # ê°„ë‹¨í•œ íŒ¨í„´ ë§¤ì¹­ (í´ë°±)
        # ì˜ˆ: "1. [CRITICAL] missing_payment_terms"
        lines = text.split('\n')
        current_risk = {}

        for line in lines:
            # ë¦¬ìŠ¤í¬ íƒ€ì… ê°ì§€
            if re.match(r'\d+\.\s*\[', line):
                if current_risk:
                    risks.append(current_risk)
                current_risk = {
                    "type": "unknown",
                    "severity": "medium",
                    "current": "",
                    "risk": "íŒŒì‹± ì‹¤íŒ¨",
                    "recommendation": "ìˆ˜ë™ í™•ì¸ í•„ìš”"
                }

                # severity ì¶”ì¶œ
                if 'CRITICAL' in line.upper():
                    current_risk["severity"] = "critical"
                elif 'HIGH' in line.upper():
                    current_risk["severity"] = "high"

        if current_risk:
            risks.append(current_risk)

        return risks[:3]  # ìµœëŒ€ 3ê°œ

    def _basic_risk_check(self, email_content: str) -> List[Dict]:
        """
        ê¸°ë³¸ ë¦¬ìŠ¤í¬ ì²´í¬ (LLM ì‹¤íŒ¨ ì‹œ í´ë°±)

        Args:
            email_content: ì´ë©”ì¼ ë‚´ìš©

        Returns:
            ê¸°ë³¸ ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸
        """
        risks = []
        email_lower = email_content.lower()

        # ê²°ì œ ì¡°ê±´ ì²´í¬
        if not any(kw in email_lower for kw in ["payment", "t/t", "l/c", "deposit"]):
            risks.append({
                "type": "missing_payment_terms",
                "severity": "high",
                "current": "(ê²°ì œ ì¡°ê±´ ë¯¸ëª…ì‹œ)",
                "risk": "ê²°ì œ ì‹œê¸° ë¶ˆëª…í™•, ë¶„ìŸ ê°€ëŠ¥ì„±",
                "recommendation": "Payment terms: T/T 30% deposit, 70% before shipment"
            })

        # Incoterms ì²´í¬
        if not any(kw in email_lower for kw in ["fob", "cif", "exw", "ddp"]):
            risks.append({
                "type": "missing_incoterms",
                "severity": "high",
                "current": "(Incoterms ë¯¸ëª…ì‹œ)",
                "risk": "ìš´ì†¡ë¹„ ë° ì±…ì„ ë²”ìœ„ ë¶ˆëª…í™•",
                "recommendation": "Specify Incoterms (e.g., FOB Shanghai)"
            })

        # ê³µê²©ì  í†¤ ì²´í¬
        if any(kw in email_lower for kw in ["i need", "you must", "immediately", "urgent"]):
            risks.append({
                "type": "aggressive_tone",
                "severity": "medium",
                "current": "ëª…ë ¹ì¡°/ì••ë°• í‘œí˜„ ì‚¬ìš©",
                "risk": "ë°”ì´ì–´ ë¶ˆì¾Œê°, ê´€ê³„ ì•…í™”",
                "recommendation": "Could you please / We would appreciate ë“± ì •ì¤‘í•œ í‘œí˜„ ì‚¬ìš©"
            })

        return risks

    def _analyze_tone(
        self,
        email_content: str,
        retrieved_emails: List,
        context: Dict
    ) -> Dict:
        """
        ì´ë©”ì¼ í†¤ ë¶„ì„

        Args:
            email_content: ì´ë©”ì¼ ë‚´ìš©
            retrieved_emails: ì°¸ê³  ì´ë©”ì¼
            context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ (ìˆ˜ì‹ ì êµ­ê°€ ë“±)

        Returns:
            {
                "current_tone": str,
                "recommended_tone": str,
                "score": float,
                "summary": str,
                "issues": List[str],
                "improvements": List[str]
            }
        """
        recipient_country = context.get("recipient_country", "")
        formatted_emails = self._format_retrieved_docs_for_prompt(retrieved_emails)

        # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        prompt = self.prompts["tone"].format(
            email_content=email_content,
            recipient_country=recipient_country or "N/A (assume global professional standard)",
            relationship=context.get("relationship", "unknown"),
            purpose=context.get("purpose", "unknown"),
            retrieved_emails=formatted_emails
        )

        # LLM í˜¸ì¶œ
        try:
            response = self._llm.invoke(prompt)
            tone_result = self._parse_tone_response(response)
            return tone_result

        except Exception as e:
            self._logger.warning(f"Tone analysis error: {e}")
            # í´ë°±: ê¸°ë³¸ í†¤ ë¶„ì„
            return {
                "current_tone": "unknown",
                "recommended_tone": "professional",
                "score": 5.0,
                "summary": f"í†¤ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}",
                "issues": [],
                "improvements": []
            }

    def _parse_tone_response(self, response: str) -> Dict:
        """
        LLM í†¤ ë¶„ì„ ì‘ë‹µ íŒŒì‹±

        Args:
            response: LLM ì‘ë‹µ (JSON í˜•ì‹ ê¸°ëŒ€)

        Returns:
            íŒŒì‹±ëœ í†¤ ë¶„ì„ ê²°ê³¼
        """
        # JSON ë¸”ë¡ ì¶”ì¶œ
        json_match = re.search(r'```json\n(.*?)\n```', response, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
        else:
            json_str = response.strip()

        try:
            parsed = json.loads(json_str)
            # ê¸°ë³¸ê°’ ì„¤ì •
            return {
                "current_tone": parsed.get("current_tone", "unknown"),
                "recommended_tone": parsed.get("recommended_tone", "professional"),
                "score": float(parsed.get("score", 5.0)),
                "summary": parsed.get("summary", "í†¤ ë¶„ì„ ì™„ë£Œ"),
                "issues": parsed.get("issues", []),
                "improvements": parsed.get("improvements", []),
                "cultural_notes": parsed.get("cultural_notes", [])
            }

        except (json.JSONDecodeError, ValueError) as e:
            self._logger.warning(f"Tone JSON parsing failed: {e}")
            # í´ë°±: í…ìŠ¤íŠ¸ì—ì„œ ì¶”ì¶œ
            return {
                "current_tone": "unknown",
                "recommended_tone": "professional",
                "score": 5.0,
                "summary": response[:200],
                "issues": [],
                "improvements": []
            }

    def _generate_improvement_complete(
        self,
        email_content: str,
        risks: List[Dict],
        tone_analysis: Dict,
        retrieved_emails: List
    ) -> str:
        """
        ì™„ì „í•œ ìˆ˜ì •ì•ˆ ìƒì„± (LLM ì‚¬ìš©)

        Args:
            email_content: ì›ë³¸ ì´ë©”ì¼
            risks: íƒì§€ëœ ë¦¬ìŠ¤í¬
            tone_analysis: í†¤ ë¶„ì„ ê²°ê³¼
            retrieved_emails: ì°¸ê³  ì´ë©”ì¼

        Returns:
            ì™„ì „íˆ ê°œì„ ëœ ì´ë©”ì¼
        """
        if not risks and tone_analysis.get('score', 0) >= 8:
            return email_content + "\n\nâœ… ì´ë©”ì¼ì´ ì´ë¯¸ ìš°ìˆ˜í•©ë‹ˆë‹¤. ìˆ˜ì • ë¶ˆí•„ìš”."

        # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        formatted_risks = self._format_risks(risks)
        formatted_emails = self._format_retrieved_docs_for_prompt(retrieved_emails)

        prompt = self.prompts["improvement"].format(
            email_content=email_content,
            risks=formatted_risks,
            current_tone=tone_analysis.get('current_tone', 'unknown'),
            recommended_tone=tone_analysis.get('recommended_tone', 'professional'),
            tone_score=tone_analysis.get('score', 0),
            tone_issues=', '.join(tone_analysis.get('issues', [])[:3]),
            retrieved_emails=formatted_emails
        )

        # LLM í˜¸ì¶œ
        try:
            improved = self._llm.invoke(prompt)

            # "ê°œì„ ëœ ì´ë©”ì¼:" ê°™ì€ ì ‘ë‘ì–´ ì œê±°
            if improved.startswith("ê°œì„ ëœ ì´ë©”ì¼:"):
                improved = improved.replace("ê°œì„ ëœ ì´ë©”ì¼:", "").strip()

            return improved

        except Exception as e:
            self._logger.warning(f"Improvement generation error: {e}")
            # í´ë°±: ê°„ë‹¨í•œ ìˆ˜ì •ì•ˆ
            return self._generate_improvement_simple(email_content, risks, retrieved_emails)

    def _generate_improvement_simple(
        self,
        email_content: str,
        risks: List[Dict],
        retrieved_emails: List
    ) -> str:
        """
        ë¦¬ìŠ¤í¬ ê¸°ë°˜ ê°„ë‹¨í•œ ìˆ˜ì •ì•ˆ ìƒì„± (í´ë°±ìš©)

        Args:
            email_content: ì›ë³¸ ì´ë©”ì¼
            risks: íƒì§€ëœ ë¦¬ìŠ¤í¬
            retrieved_emails: ì°¸ê³  ì´ë©”ì¼

        Returns:
            ê°œì„ ëœ ì´ë©”ì¼
        """
        if not risks:
            return email_content + "\n\nâœ… ë°œê²¬ëœ ë¦¬ìŠ¤í¬ ì—†ìŒ. í˜„ì¬ ì´ë©”ì¼ì´ ì ì ˆí•©ë‹ˆë‹¤."

        # ê°„ë‹¨í•œ ìˆ˜ì •ì•ˆ
        improvements = []
        for risk in risks:
            improvements.append(f"- {risk['recommendation']}")

        return f"""{email_content}

[ê°œì„  ì œì•ˆ]
{chr(10).join(improvements)}"""

    def _format_risks(self, risks: List[Dict]) -> str:
        """
        ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ í¬ë§·

        Args:
            risks: ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸

        Returns:
            í¬ë§·ëœ ë¬¸ìì—´
        """
        if not risks:
            return "âœ… ë°œê²¬ëœ ë¦¬ìŠ¤í¬ ì—†ìŒ! ì´ë©”ì¼ì´ ì•ˆì „í•©ë‹ˆë‹¤."

        formatted = []
        severity_icon = {
            "critical": "ğŸ”´",
            "high": "ğŸŸ ",
            "medium": "ğŸŸ¡",
            "low": "ğŸŸ¢"
        }

        for i, risk in enumerate(risks, 1):
            icon = severity_icon.get(risk.get("severity", "medium"), "âšª")
            severity = risk.get("severity", "medium").upper()
            risk_type = risk.get("type", "unknown")
            current = risk.get("current", "N/A")
            risk_desc = risk.get("risk", "N/A")
            recommendation = risk.get("recommendation", "N/A")

            formatted.append(f"""**{i}. [{icon} {severity}] {risk_type}**
- í˜„ì¬: "{current}"
- ë¦¬ìŠ¤í¬: {risk_desc}
- ê¶Œì¥: {recommendation}
""")

        return "\n".join(formatted)

    def _format_improvements(self, risks: List[Dict]) -> str:
        """
        ê°œì„  í¬ì¸íŠ¸ ìš”ì•½

        Args:
            risks: ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸

        Returns:
            ê°œì„  í¬ì¸íŠ¸ ë¬¸ìì—´
        """
        if not risks:
            return "âœ… ê°œì„  í•„ìš” ì‚¬í•­ ì—†ìŒ"

        improvements = []
        for i, risk in enumerate(risks[:3], 1):  # ìƒìœ„ 3ê°œë§Œ
            risk_type = risk.get("type", "unknown").replace("_", " ").title()
            recommendation = risk.get("recommendation", "N/A")
            improvements.append(f"{i}. **{risk_type}**: {recommendation}")

        return "\n".join(improvements)

    def _format_improvements_with_tone(
        self,
        risks: List[Dict],
        tone_analysis: Dict
    ) -> str:
        """
        ë¦¬ìŠ¤í¬ + í†¤ ë¶„ì„ ê¸°ë°˜ ê°œì„  í¬ì¸íŠ¸ ìš”ì•½

        Args:
            risks: ë¦¬ìŠ¤í¬ ë¦¬ìŠ¤íŠ¸
            tone_analysis: í†¤ ë¶„ì„ ê²°ê³¼

        Returns:
            ê°œì„  í¬ì¸íŠ¸ ë¬¸ìì—´
        """
        improvements = []

        # ë¦¬ìŠ¤í¬ ê¸°ë°˜ ê°œì„ ì  (ìƒìœ„ 3ê°œ)
        for i, risk in enumerate(risks[:3], 1):
            risk_type = risk.get("type", "unknown").replace("_", " ").title()
            improvements.append(f"{i}. âœ… **{risk_type}**: {risk.get('recommendation', 'N/A')[:80]}...")

        # í†¤ ê°œì„ ì 
        if tone_analysis.get('score', 10) < 8:
            tone_improvements = tone_analysis.get('improvements', [])
            for improvement in tone_improvements[:2]:  # ìµœëŒ€ 2ê°œ
                improvements.append(f"{len(improvements)+1}. ğŸ¨ **í†¤ ê°œì„ **: {improvement[:80]}...")

        return "\n".join(improvements) if improvements else "âœ… ê°œì„  í•„ìš” ì‚¬í•­ ì—†ìŒ"

    def _format_retrieved_docs_for_prompt(self, docs: List) -> str:
        """
        RAG ê²€ìƒ‰ ê²°ê³¼ë¥¼ LLM í”„ë¡¬í”„íŠ¸ìš©ìœ¼ë¡œ í¬ë§·

        Args:
            docs: retriever ê²€ìƒ‰ ê²°ê³¼ (RetrievedDocument ê°ì²´ ë¦¬ìŠ¤íŠ¸)

        Returns:
            í”„ë¡¬í”„íŠ¸ì— ì£¼ì…í•  ë¬¸ìì—´
        """
        if not docs:
            return "ê´€ë ¨ ì´ë©”ì¼ ìƒ˜í”Œì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¼ë°˜ì ì¸ ë¹„ì¦ˆë‹ˆìŠ¤ ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”."

        formatted = []
        for i, doc in enumerate(docs, 1):
            content = doc.content
            metadata = doc.metadata

            formatted.append(f"""[ìƒ˜í”Œ {i}]
ë‚´ìš©: {content}
ìƒí™©: {metadata.get('situation', 'N/A')}
ì¶œì²˜: {metadata.get('source_dataset', 'unknown')}
""")

        return "\n".join(formatted)

    def _generate_checklist(self, email_content: str) -> str:
        """
        ì´ë©”ì¼ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ 5W1H ì²´í¬ë¦¬ìŠ¤íŠ¸ ìƒì„±

        Args:
            email_content: ìƒì„±ëœ ì´ë©”ì¼ ì „ë¬¸

        Returns:
            ì²´í¬ë¦¬ìŠ¤íŠ¸ (ë§ˆí¬ë‹¤ìš´ í˜•ì‹)
        """
        email_lower = email_content.lower()

        # 5W1H ì²´í¬ í•­ëª©
        checks = [
            {
                "item": "ì œí’ˆ/ì„œë¹„ìŠ¤ ì •ë³´ ëª…ì‹œ",
                "keywords": ["product", "item", "service", "goods", "equipment", "material"],
                "checked": False
            },
            {
                "item": "ìˆ˜ëŸ‰/ì‚¬ì–‘ ëª…ì‹œ",
                "keywords": ["quantity", "unit", "pcs", "spec", "specification", "model", "ton", "kg"],
                "checked": False
            },
            {
                "item": "ë‚©ê¸°/ê¸°í•œ ëª…ì‹œ",
                "keywords": ["delivery", "deadline", "date", "schedule", "shipment", "by", "until"],
                "checked": False
            },
            {
                "item": "Incoterms í¬í•¨",
                "keywords": ["fob", "cif", "exw", "ddp", "ddu", "incoterm"],
                "checked": False
            },
            {
                "item": "ê²°ì œ ì¡°ê±´ í¬í•¨",
                "keywords": ["payment", "t/t", "l/c", "deposit", "balance", "bank", "wire transfer"],
                "checked": False
            }
        ]

        # í‚¤ì›Œë“œ ê¸°ë°˜ ì²´í¬
        for check in checks:
            if any(kw in email_lower for kw in check["keywords"]):
                check["checked"] = True

        # ë§ˆí¬ë‹¤ìš´ í¬ë§·íŒ…
        checklist_lines = []
        for check in checks:
            icon = "âœ…" if check["checked"] else "âš ï¸"
            status = "í¬í•¨ë¨" if check["checked"] else "í™•ì¸ í•„ìš”"
            checklist_lines.append(f"- {icon} **{check['item']}**: {status}")

        return "\n".join(checklist_lines)

    def _format_retrieved_docs(self, docs: List) -> str:
        """
        RAG ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì½ê¸° ì‰¬ìš´ í˜•ì‹ìœ¼ë¡œ í¬ë§·

        Args:
            docs: retriever.search() ê²°ê³¼ (RetrievedDocument ê°ì²´ ë¦¬ìŠ¤íŠ¸)

        Returns:
            í¬ë§·ëœ ë¬¸ìì—´ (ë§ˆí¬ë‹¤ìš´)
        """
        if not docs:
            return "âŒ ê´€ë ¨ ë¬¸ì„œë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."

        formatted = []
        for i, doc in enumerate(docs, 1):
            content = doc.content
            metadata = doc.metadata
            distance = doc.distance

            # ì‹ ë¢°ë„ í‘œì‹œ (distanceê°€ ë‚®ì„ìˆ˜ë¡ ìœ ì‚¬ë„ ë†’ìŒ)
            if distance < 0.5:
                confidence = "ğŸŸ¢ [ë†’ì€ ìœ ì‚¬ë„]"
            elif distance < 1.0:
                confidence = "ğŸŸ¡ [ì¤‘ê°„ ìœ ì‚¬ë„]"
            else:
                confidence = "âšª [ë‚®ì€ ìœ ì‚¬ë„]"

            # ì¶œì²˜
            source = metadata.get("source_dataset", "unknown")

            # í¬ë§·íŒ…
            formatted.append(f"""**{i}. {confidence}** (ê±°ë¦¬: {distance:.2f})
- ë‚´ìš©: {content[:100]}{"..." if len(content) > 100 else ""}
- ì¶œì²˜: {source}
""")

        return "\n".join(formatted)

    def _extract_email_from_input(self, user_input: str) -> str:
        """
        user_inputì—ì„œ ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ

        ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±:
        - ":" ì´í›„ í…ìŠ¤íŠ¸ë¥¼ ì´ë©”ì¼ë¡œ ê°„ì£¼
        - ì—¬ëŸ¬ ì¤„ì¸ ê²½ìš° ì „ì²´ ì¶”ì¶œ

        Args:
            user_input: ì‚¬ìš©ì ì…ë ¥

        Returns:
            ì¶”ì¶œëœ ì´ë©”ì¼ ë‚´ìš© (ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´)
        """
        if ":" in user_input:
            # "ê²€í† í•´ì¤˜: Hi, ..." í˜•ì‹
            parts = user_input.split(":", 1)
            if len(parts) > 1:
                return parts[1].strip()

        return ""

    def _format_sources(self, sources: List[str]) -> str:
        """
        ì¶œì²˜ ëª©ë¡ì„ ë¬¸ìì—´ë¡œ í¬ë§·

        Args:
            sources: ì¶œì²˜ ID ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["emails.json", "mistakes.json"])

        Returns:
            í¬ë§·ëœ ë¬¸ìì—´ (ì˜ˆ: "emails.json, mistakes.json")
        """
        if not sources:
            return "N/A"

        # ì¤‘ë³µ ì œê±°
        unique_sources = list(set(sources))

        return ", ".join(unique_sources[:3])  # ìµœëŒ€ 3ê°œë§Œ í‘œì‹œ
