가상사례 대표 11

id,risk_type,supervisor_feedback,expected_loss 

M005,금액 불일치,"""품목별 합계와 최종 금액이 맞지 않습니다. 계산 실수나 오타는 신뢰도를 크게 떨어뜨립니다. 다시 계산해 보세요.""","$45,000 + 과태료"
M010,송금 정보 오류,"""은행명(영국)과 SWIFT 코드(한국)의 국가 정보가 다릅니다. 이대로 송금하면 자금 회수가 불가능할 수 있습니다!""","송금액 전액 (최대 $10만+)"
M019,보험 가입 누락,"""CIF 조건은 우리가 보험을 들어야 합니다. 현재 보험 서류가 누락되었습니다. 사고 발생 시 독박을 쓸 수 있어요.""","화물 가액 전체 ($5만~20만)"
M001,이름 오타,"""수하인 이름에 오타가 보입니다. 철자 하나만 틀려도 현지에서 물건을 못 찾고 재발행 비용이 발생합니다.""","$500 ~ $1,500"
M003,운임 조건 불일치,"""계약은 선불인데 B/L은 후불로 되어 있네요. 항구에서 화물 인도가 거부되어 창고료가 발생할 수 있습니다.""","$500 ~ $2,000"
M004,HS Code 오류,"""입력한 코드는 일반 시계용입니다. 스마트 기기는 다른 코드를 써야 관세 포탈 의심을 피할 수 있습니다.""","포탈 세액의 3배 + 가산세"
M008,선적 기한 미준수,"""L/C 기한보다 선적이 늦어질 예정입니다. 바이어가 이를 빌미로 대금 지급을 거절하거나 깎을 수 있습니다.""","계약 금액의 5~10% 감액"
M012,조건 미비,"""FOB 뒤에 선적항 이름이 빠졌습니다. 어디서부터 우리가 운송비를 내야 하는지 분쟁이 생길 수 있어요.""","$1,000 ~ $5,000"
M013,품질 기준 모호,"""'좋은 품질' 같은 표현은 위험합니다. 구체적인 수치나 ISO 기준을 넣어야 나중에 불량품 반품이 가능합니다.""","재고 폐기 비용 (매입가 100%)"
M016,원가 정보 노출,"""첨부파일에 내부 마진 계산 시트가 포함되었습니다! 바이어가 우리 마진을 알면 향후 협상이 불가능해집니다.""","기대 마진의 10~20% 삭감"
M017,즉시 책임 인정,"""사고 원인이 밝혀지기 전에 과실을 인정하면 안 됩니다. 보험사에서 보험금 지급을 거절할 명분이 됩니다.""","손해액 전액 부담 (보험 불가)"

1-2) scripts/csv_to_mistakes_json.py

import csv
import json
from pathlib import Path

REQUIRED = ["id", "risk_type", "supervisor_feedback", "expected_loss"]

def clean_triple_quotes(s: str) -> str:
    s = (s or "").strip()
    if s.startswith('"""') and s.endswith('"""'):
        s = s[3:-3].strip()
    return s

def embed_text(row: dict) -> str:
    return (
        f"ID: {row['id']}\n"
        f"리스크 유형: {row['risk_type']}\n"
        f"사수 피드백: {row['supervisor_feedback']}\n"
        f"예상 손실: {row['expected_loss']}\n"
    )

def main():
    in_path = Path("data/mistakes_seed.csv")
    out_path = Path("data/mistakes.json")
    out_path.parent.mkdir(parents=True, exist_ok=True)

    items = []
    with in_path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        for r in reader:
            for k in REQUIRED:
                if k not in r or not (r[k] or "").strip():
                    raise ValueError(f"Missing {k}: {r}")
            item = {
                "id": r["id"].strip(),
                "risk_type": r["risk_type"].strip(),
                "supervisor_feedback": clean_triple_quotes(r["supervisor_feedback"]),
                "expected_loss": r["expected_loss"].strip(),
            }
            item["embed_text"] = embed_text(item)
            items.append(item)

    out_path.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"OK: {len(items)} -> {out_path}")

if __name__ == "__main__":
    main()


1-3) 실행

python scripts/csv_to_mistakes_json.py

[2] mistakes.json → Chroma Vector DB 구축(RAG용)

2-1) scripts/build_vector_db.py

import json
from pathlib import Path

try:
    from langchain_chroma import Chroma
except Exception:
    from langchain.vectorstores import Chroma

from langchain_core.documents import Document
from langchain_upstage import UpstageEmbeddings

def main():
    data_path = Path("data/mistakes.json")
    persist_dir = Path("vector_db")
    persist_dir.mkdir(parents=True, exist_ok=True)

    items = json.loads(data_path.read_text(encoding="utf-8"))

    docs = []
    for it in items:
        docs.append(
            Document(
                page_content=it["embed_text"],
                metadata={
                    "id": it["id"],
                    "risk_type": it["risk_type"],
                    "expected_loss": it["expected_loss"],
                },
            )
        )

    embeddings = UpstageEmbeddings()

    vs = Chroma.from_documents(
        documents=docs,
        embedding=embeddings,
        persist_directory=str(persist_dir),
        collection_name="mistakes",
    )
    vs.persist()
    print(f"OK: vector_db built docs={len(docs)} dir={persist_dir}")

if __name__ == "__main__":
    main()

2-2) 실행
python scripts/build_vector_db.py


[3] Case 자동 실행 + 출력 JSON 자동 채점

3-1) scripts/batch_runner.py

import json
from pathlib import Path
from typing import Dict, List, Tuple

from mistake_predict_agent import MistakePredictAgent

REQUIRED_TOP = ["analysis_id", "input_summary", "risk_factors", "risk_scoring", "loss_description", "confidence_score"]
REQUIRED_RS = ["impact_score", "likelihood_score", "total_risk_score", "risk_level"]
MUST_KW = ["손실", "지연", "과태료", "클레임", "예방", "검토"]

def score(out: Dict) -> Tuple[int, List[str]]:
    missing = []
    for k in REQUIRED_TOP:
        if k not in out:
            missing.append(f"missing_top:{k}")

    rs = out.get("risk_scoring", {})
    if not isinstance(rs, dict):
        missing.append("risk_scoring:not_dict")
    else:
        for k in REQUIRED_RS:
            if k not in rs:
                missing.append(f"missing_risk_scoring:{k}")

    blob = json.dumps(out, ensure_ascii=False)
    hits = sum(1 for kw in MUST_KW if kw in blob)

    s = 0
    if len(missing) == 0:
        s += 70
    s += min(30, hits * 10)
    if len(missing) > 0:
        s = min(s, 60)
    return s, missing

def main():
    cases = json.loads(Path("data/mistakes.json").read_text(encoding="utf-8"))
    out_dir = Path("batch_outputs")
    out_dir.mkdir(parents=True, exist_ok=True)

    agent = MistakePredictAgent()

    report = []
    for it in cases:
        scenario = it["embed_text"]
        out = agent.analyze(scenario)

        s, missing = score(out)
        passed = (len(missing) == 0) and (s >= 80)

        report.append({
            "id": it["id"],
            "risk_type": it["risk_type"],
            "expected_loss": it["expected_loss"],
            "score": s,
            "pass": passed,
            "missing": missing,
        })

        (out_dir / f"{it['id']}.json").write_text(json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8")

    (out_dir / "report.json").write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"OK: total={len(report)} pass={sum(1 for r in report if r['pass'])} -> {out_dir/'report.json'}")

if __name__ == "__main__":
    main()

3-2) 실행
python scripts/batch_runner.py







